/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include <crc16.h>
#include "sysinit/sysinit.h"
#include "host/ble_hs.h"
#include "host/ble_uuid.h"
#include "os/endian.h"
#include "services/cus_inc/ble_svc_voice.h"

/****************************************************************************
 * Private Types
 ****************************************************************************/


/****************************************************************************
 * Private Function Prototypes
 ****************************************************************************/

/****************************************************************************
 * Public Data
 ****************************************************************************/
/* UUID generated by http://www.guidgenerator.com {d3e845c1-edfa-41c7-b7a4-12624705f63c}*/

/* {c9b60001-4540-43f4-9715-c0743af859ca} */
const ble_uuid128_t gatt_svr_svc_voice_uuid =
    BLE_UUID128_INIT(0x3c, 0xf6, 0x05, 0x47, 0x62, 0x12, 0xa4, 0xb7,
                     0xc7, 0x41, 0xfa, 0xed, 0x01, 0x00, 0xe8, 0xd3);

/* {c9b60002-4540-43f4-9715-c0743af859ca} */
const ble_uuid128_t gatt_svr_chr_voice_read_uuid =
    BLE_UUID128_INIT(0x3c, 0xf6, 0x05, 0x47, 0x62, 0x12, 0xa4, 0xb7,
                     0xc7, 0x41, 0xfa, 0xed, 0x02, 0x00, 0xe8, 0xd3);

/* {c9b60003-4540-43f4-9715-c0743af859ca} */
const ble_uuid128_t gatt_svr_chr_voice_write_uuid =
    BLE_UUID128_INIT(0x3c, 0xf6, 0x05, 0x47, 0x62, 0x12, 0xa4, 0xb7,
                     0xc7, 0x41, 0xfa, 0xed, 0x03, 0x00, 0xe8, 0xd3);

/* {c9b60004-4540-43f4-9715-c0743af859ca} */
const ble_uuid128_t gatt_svr_chr_voice_ntf_uuid =
    BLE_UUID128_INIT(0x3c, 0xf6, 0x05, 0x47, 0x62, 0x12, 0xa4, 0xb7,
                     0xc7, 0x41, 0xfa, 0xed, 0x04, 0x00, 0xe8, 0xd3);

/****************************************************************************
 * Private Data
 ****************************************************************************/
static ble_app_handler * voice_app_handler = NULL;

/* ble voice attr handle */
static uint16_t g_ble_svc_voice_attr_read_handle;

static uint16_t g_ble_svc_voice_attr_write_handle;

static uint16_t g_ble_svc_voice_attr_ntf_handle;

static uint16_t g_svc_voice_conn_handle = BLE_APP_INVALID_CONN_HANDLE;

/**
 * The vendor specific "ble_svc_voice" service consists of one write no-rsp characteristic
 * and one notification only read charateristic
 *     o "write no-rsp": a single-byte characteristic that can be written only
 *       over a non-encrypted connection
 *     o "read": a single-byte characteristic that can always be read only via
 *       notifications
 */
static int
ble_svc_voice_chr_access(uint16_t conn_handle, uint16_t attr_handle,
                              struct ble_gatt_access_ctxt *ctxt, void *arg);

static const struct ble_gatt_svc_def gatt_voice_svr_svcs[] = {
    {
        /* Service: uart */
        .type = BLE_GATT_SVC_TYPE_PRIMARY,
        .uuid = &gatt_svr_svc_voice_uuid.u,
        .characteristics = (struct ble_gatt_chr_def[]) {
          {
              .uuid = &gatt_svr_chr_voice_read_uuid.u,
              .val_handle = &g_ble_svc_voice_attr_read_handle,
              .access_cb = ble_svc_voice_chr_access,
              .flags = BLE_GATT_CHR_F_READ,
          },
          {
              .uuid = &gatt_svr_chr_voice_write_uuid.u,
              .val_handle = &g_ble_svc_voice_attr_write_handle,
              .access_cb = ble_svc_voice_chr_access,
              .flags = BLE_GATT_CHR_F_WRITE | BLE_GATT_CHR_F_WRITE_NO_RSP,
          },
          {
              .uuid = &gatt_svr_chr_voice_ntf_uuid.u,
              .val_handle = &g_ble_svc_voice_attr_ntf_handle,
              .access_cb = ble_svc_voice_chr_access,
              .flags = BLE_GATT_CHR_F_NOTIFY,
          },
          {
              0, /* No more characteristics in this service */
          }
        },
    },
    {
        0, /* No more services */
    },
};

/****************************************************************************
 * Private Functions
 ****************************************************************************/
static void
ble_svc_voice_ntf_data(uint8_t * data, uint16_t len)
{
    struct os_mbuf *om;

    om = ble_hs_mbuf_from_flat(data, len);
    if (!om) {
        BLE_HS_LOG(ERROR, "BLE VOICE NTF malloc buffer failed...\n");
        return;
    }
    assert(g_svc_voice_conn_handle != BLE_APP_INVALID_CONN_HANDLE);
    ble_gattc_notify_custom(g_svc_voice_conn_handle,
                            g_ble_svc_voice_attr_ntf_handle, om);
}

static void
ble_svc_voice_set_conn_handle(uint16_t conn_handle)
{
  g_svc_voice_conn_handle = conn_handle;
}

static int
ble_svc_voice_chr_access(uint16_t conn_handle, uint16_t attr_handle,
                               struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    uint32_t ret;
    (void)ret;

    switch (ctxt->op) {
        case BLE_GATT_ACCESS_OP_WRITE_CHR:
          {
            uint16_t len = 0;
            uint8_t * write_data;
            
            len = OS_MBUF_PKTLEN(ctxt->om);
            if(len > BLE_APP_COMMAND_LEN)
              {
                BLE_HS_LOG(ERROR, "Write a not valid command len[%d]...\n", len);
                return 0;
              }

            write_data = malloc(BLE_APP_COMMAND_LEN);
            assert(write_data != NULL);
            memset(write_data, 0, BLE_APP_COMMAND_LEN);

            ret = os_mbuf_copydata(ctxt->om, 0, len, write_data);
            if( voice_app_handler->write){
               voice_app_handler->write(write_data, len);
            }
            else{
              BLE_HS_LOG(ERROR, "Ble write handler is NULL...\n");
            }
            free(write_data);
            return 0;
          }
        case BLE_GATT_ACCESS_OP_WRITE_DSC:
            return 0;

        case BLE_GATT_ACCESS_OP_READ_CHR:
          {
            uint16_t len = 0;
            uint8_t * data;
            data = malloc(BLE_APP_MAX_DATA_LEN);
            memset(data, 0, BLE_APP_MAX_DATA_LEN);
            assert(data != NULL);
            if( voice_app_handler->read){
                voice_app_handler->read(data, &len);
              }
            else{
              BLE_HS_LOG(ERROR, "BLE demo read handler is NULL...\n");
              }
            if(len != 0){
              os_mbuf_append(ctxt->om, data, len);
            } else {
              BLE_HS_LOG(ERROR, "Get local demo information failed...\n");
            }
            free(data);
            return 0;
          }
        case BLE_GATT_ACCESS_OP_READ_DSC:
            return 0;

        default:
            assert(0);
            return BLE_ATT_ERR_UNLIKELY;
    }
}


/**
 * ble_svc_voice GATT server initialization
 *
 */
static int
ble_svc_voice_gatt_svr_init(void)
{
    int rc;

    rc = ble_gatts_count_cfg(gatt_voice_svr_svcs);
    if (rc != 0) {
        goto err;
    }

    rc = ble_gatts_add_svcs(gatt_voice_svr_svcs);
    if (rc != 0) {
        return rc;
    }

err:
    return rc;
}

/****************************************************************************
 * Public Functions
 ****************************************************************************/
/**
 * ble_svc_voice sevices initialization
 *
 */
void
ble_svc_voice_init(ble_app_handler * handler)
{
  assert(handler);  
  voice_app_handler = handler;
  voice_app_handler->notify = ble_svc_voice_ntf_data;
  voice_app_handler->set_conn_handle = ble_svc_voice_set_conn_handle;
  ble_svc_voice_gatt_svr_init();
}

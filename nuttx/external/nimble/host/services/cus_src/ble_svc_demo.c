/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include <crc16.h>
#include "sysinit/sysinit.h"
#include "host/ble_hs.h"
#include "host/ble_uuid.h"
#include "os/endian.h"
#include "services/cus_inc/ble_svc_demo.h"

/****************************************************************************
 * Private Types
 ****************************************************************************/

/****************************************************************************
 * Private Function Prototypes
 ****************************************************************************/

/****************************************************************************
 * Public Data
 ****************************************************************************/
/* UUID generated by http://www.guidgenerator.com {3eb20001-8977-4323-8912-7074e88f9607}*/


/* {3eb20001-8977-4323-8912-7074e88f9607} */
const ble_uuid128_t gatt_svr_svc_demo_uuid =
    BLE_UUID128_INIT(0x07, 0x96, 0x8f, 0xe8, 0x74, 0x70, 0x12, 0x89,
                     0x23, 0x43, 0x77, 0x89, 0x01, 0x00, 0xb2, 0x3e);

/* {3eb20002-8977-4323-8912-7074e88f9607} */
const ble_uuid128_t gatt_svr_chr_demo_read_uuid =
    BLE_UUID128_INIT(0x07, 0x96, 0x8f, 0xe8, 0x74, 0x70, 0x12, 0x89,
                     0x23, 0x43, 0x77, 0x89, 0x02, 0x00, 0xb2, 0x3e);

/* {3eb20003-8977-4323-8912-7074e88f9607} */
const ble_uuid128_t gatt_svr_chr_demo_write_uuid =
    BLE_UUID128_INIT(0x07, 0x96, 0x8f, 0xe8, 0x74, 0x70, 0x12, 0x89,
                     0x23, 0x43, 0x77, 0x89, 0x03, 0x00, 0xb2, 0x3e);

/* {3eb20004-8977-4323-8912-7074e88f9607} */
const ble_uuid128_t gatt_svr_chr_demo_notify_uuid =
    BLE_UUID128_INIT(0x07, 0x96, 0x8f, 0xe8, 0x74, 0x70, 0x12, 0x89,
                     0x23, 0x43, 0x77, 0x89, 0x04, 0x00, 0xb2, 0x3e);

/****************************************************************************
 * Private Data
 ****************************************************************************/
static ble_demo_handler demo_handler = {0};

/**
 * The vendor specific "ble_svc_demo" service consists of one write no-rsp characteristic
 * and one notification only read charateristic
 *     o "write no-rsp": a single-byte characteristic that can be written only
 *       over a non-encrypted connection
 *     o "read": a single-byte characteristic that can always be read only via
 *       notifications
 */

/* ble demo attr handle */
static uint16_t g_ble_svc_demo_attr_read_handle;

static uint16_t g_ble_svc_demo_attr_write_handle;

static uint16_t g_ble_svc_demo_attr_notify_handle;

static uint16_t g_svc_demo_conn_handle;

static int
ble_svc_demo_chr_access(uint16_t conn_handle, uint16_t attr_handle,
                              struct ble_gatt_access_ctxt *ctxt, void *arg);

static const struct ble_gatt_svc_def gatt_demo_svr_svcs[] = {
    {
        /* Service: uart */
        .type = BLE_GATT_SVC_TYPE_PRIMARY,
        .uuid = &gatt_svr_svc_demo_uuid.u,
        .characteristics = (struct ble_gatt_chr_def[]) {
          {
              .uuid = &gatt_svr_chr_demo_read_uuid.u,
              .val_handle = &g_ble_svc_demo_attr_read_handle,
              .access_cb = ble_svc_demo_chr_access,
              .flags = BLE_GATT_CHR_F_READ,
          },
          {
              .uuid = &gatt_svr_chr_demo_write_uuid.u,
              .val_handle = &g_ble_svc_demo_attr_write_handle,
              .access_cb = ble_svc_demo_chr_access,
              .flags = BLE_GATT_CHR_F_WRITE | BLE_GATT_CHR_F_WRITE_NO_RSP,
          },
          {
              .uuid = &gatt_svr_chr_demo_notify_uuid.u,
              .val_handle = &g_ble_svc_demo_attr_notify_handle,
              .access_cb = ble_svc_demo_chr_access,
              .flags = BLE_GATT_CHR_F_NOTIFY,
          },
          {
              0, /* No more characteristics in this service */
          }
        },
    },
    {
        0, /* No more services */
    },
};

/****************************************************************************
 * Private Functions
 ****************************************************************************/
static int
ble_svc_demo_chr_access(uint16_t conn_handle, uint16_t attr_handle,
                               struct ble_gatt_access_ctxt *ctxt, void *arg)
{
    uint32_t ret;
    (void)ret;

    switch (ctxt->op) {
        case BLE_GATT_ACCESS_OP_WRITE_CHR:
          {
            uint16_t len = 0;
            uint8_t * write_data;
            
            write_data = malloc(BLE_SVC_DEMO_MAX_DATA_LEN);
            assert(write_data != NULL);
            memset(write_data, 0, BLE_SVC_DEMO_MAX_DATA_LEN);

            len = OS_MBUF_PKTLEN(ctxt->om);
            if(len > BLE_SVC_DEMO_MAX_DATA_LEN)
              {
                BLE_HS_LOG(ERROR, "Write a not valid command len[%d]...\n", len);
              }
            ret = os_mbuf_copydata(ctxt->om, 0, len, write_data);
            if( demo_handler.write){
               demo_handler.write(write_data, len);
            }
            else{
              BLE_HS_LOG(ERROR, "Ble write handler is NULL...\n");
            }
            free(write_data);
            return 0;
          }
        case BLE_GATT_ACCESS_OP_WRITE_DSC:
            return 0;

        case BLE_GATT_ACCESS_OP_READ_CHR:
          {
            uint16_t len = 0;
            uint8_t * data;
            data = malloc(BLE_SVC_DEMO_INFO_LEN);
            memset(data, 0, BLE_SVC_DEMO_INFO_LEN);
            assert(data != NULL);
            if( demo_handler.read){
                demo_handler.read(data, &len);
              }
            else{
              BLE_HS_LOG(ERROR, "BLE demo read handler is NULL...\n");
              }
            if(len != 0){
              os_mbuf_append(ctxt->om, data, len);
            } else {
              BLE_HS_LOG(ERROR, "Get local demo information failed...\n");
            }
            free(data);
            return 0;
          }
        case BLE_GATT_ACCESS_OP_READ_DSC:
            return 0;

        default:
            assert(0);
            return BLE_ATT_ERR_UNLIKELY;
    }
}

/**
 * ble_svc_demo GATT server initialization
 *
 */
static int
ble_svc_demo_gatt_svr_init(void)
{
    int rc;

    rc = ble_gatts_count_cfg(gatt_demo_svr_svcs);
    if (rc != 0) {
        goto err;
    }

    rc = ble_gatts_add_svcs(gatt_demo_svr_svcs);
    if (rc != 0) {
        return rc;
    }

err:
    return rc;
}

/****************************************************************************
 * Public Functions
 ****************************************************************************/
void
ble_svc_demo_send_data(uint8_t * data, uint32_t len)
{
    struct os_mbuf *om;

    om = ble_hs_mbuf_from_flat(data, len);
    if (!om) {
        BLE_HS_LOG(ERROR, "Memory malloc failed for scv demo...\n");
        return;
    }
    if(0xff == g_svc_demo_conn_handle){
        BLE_HS_LOG(ERROR, "Connection handle is invalid...\n");
        return;
    }
    ble_gattc_notify_custom(g_svc_demo_conn_handle,
                            g_ble_svc_demo_attr_notify_handle, om);
}

void
ble_svc_demo_set_conn_handle(uint16_t conn_handle)
{
  g_svc_demo_conn_handle = conn_handle;
}

void
ble_svc_demo_init(ble_demo_handler * handler)
{
  ble_svc_demo_gatt_svr_init();
  demo_handler.read = handler->read;
  demo_handler.write = handler->write;
  demo_handler.reset = handler->reset;
}

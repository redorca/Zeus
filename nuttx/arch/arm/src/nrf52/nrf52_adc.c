/****************************************************************************
 * arch/arm/src/nrf52/nrf52_adc.c
 *
 *   Copyright (C) 2011, 2013, 2015-2017 Gregory Nutt. All rights reserved.
 *   Copyright (C) 2017 Zglue  Inc. All rights reserved.
 *   Authors: Gregory Nutt <gnutt@nuttx.org>
 *            Levin Li     <zhiqiang@zglue.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name NuttX nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/****************************************************************************
 * Included Files
 ****************************************************************************/

#include <nuttx/config.h>

#include <stdio.h>
#include <sys/types.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <semaphore.h>
#include <errno.h>
#include <assert.h>
#include <debug.h>
#include <unistd.h>

#include <arch/board/board.h>
#include <nuttx/irq.h>
#include <nuttx/arch.h>
#include <nuttx/fs/ioctl.h>
#include <nuttx/analog/adc.h>
#include <nuttx/analog/ioctl.h>

#include "up_internal.h"
#include "up_arch.h"

#include "chip.h"
#include "nrf.h"
#include "nrf_saadc.h"
#include "nrf52_adc.h"

/* ADC "upper half" support must be enabled */

#ifdef CONFIG_NRF52_ADC


/****************************************************************************
 * Pre-processor Definitions
 */
/* nrf52 only have max 8 analog channel */

#define MAX_ADC_CH_NUM  8

/* nrf52 pinmux valid value */

#define ANALOG_PINMUX_MAX_VALUE  9

#define EVT_TO_STR(event)   (event == NRF_SAADC_EVENT_STARTED ? "NRF_SAADC_EVENT_STARTED" :                         \
                            (event == NRF_SAADC_EVENT_END ? "NRF_SAADC_EVENT_END" :                                 \
                            (event == NRF_SAADC_EVENT_DONE ? "NRF_SAADC_EVENT_DONE" :                               \
                            (event == NRF_SAADC_EVENT_RESULTDONE ? "NRF_SAADC_EVENT_RESULTDONE" :                   \
                            (event == NRF_SAADC_EVENT_CALIBRATEDONE ? "NRF_SAADC_EVENT_CALIBRATEDONE" :             \
                            (event == NRF_SAADC_EVENT_STOPPED ? "NRF_SAADC_EVENT_STOPPED" : "UNKNOWN EVENT"))))))


/* ADC interrupts ***********************************************************/

#define NRF52_ADC_PRIORITY   7


/****************************************************************************
 * Private Types
 ****************************************************************************/

/* This structure describes the state of one ADC block */
#define MAX_BUF_LEN  8
struct nrf52_adc_s
{
  FAR const struct adc_callback_s *cb;
  uint8_t irq;                /* Interrupt generated by this ADC block */
  uint8_t state;
  uint8_t channel_flag;       /* every bit indicate one channel */
  uint8_t active_ch;
  uint8_t mode;               /* remember : if continue mode enable */
  bool    end_flag;           /* flag for which buffer done */
  int16_t adc_buf[MAX_BUF_LEN];
  int16_t adc_second_buf[MAX_BUF_LEN];

  uint32_t base;              /* Base address of registers unique to this ADC
                               * block */
  uint32_t irqmask;
  adc_resolution_t  resolution;
  adc_oversample_t oversample;
};

/****************************************************************************
 * Private Function Prototypes
 ****************************************************************************/

/* ADC Driver Methods */

static int  adc_bind(FAR struct adc_dev_s *dev,
                     FAR const struct adc_callback_s *callback);
static void adc_reset(FAR struct adc_dev_s *dev);
static int  adc_setup(FAR struct adc_dev_s *dev);
static void adc_shutdown(FAR struct adc_dev_s *dev);

static void up_adc_rxint(FAR struct adc_dev_s *dev, bool enable);
static void internal_adc_rxint(FAR struct nrf52_adc_s *dev, bool enable);
static int  adc_ioctl(FAR struct adc_dev_s *dev, int cmd, unsigned long arg);
static void adc_enable(FAR struct nrf52_adc_s *priv, bool enable);

static int  adc_set_channel_config(adc_channel_config_t *config);

/****************************************************************************
 * Private Data
 ****************************************************************************/

/* ADC interface operations */

static const struct adc_ops_s nrf52_adcops =
{
  .ao_bind        = adc_bind,
  .ao_reset       = adc_reset,
  .ao_setup       = adc_setup,
  .ao_shutdown    = adc_shutdown,
  .ao_rxint       = up_adc_rxint,
  .ao_ioctl       = adc_ioctl,
};

static struct nrf52_adc_s nrf52_adcpriv =
{
  .irq      = SAADC_IRQn,
  .base     = NRF_SAADC_BASE,
};

static struct adc_dev_s nrf52_adcdev =
{
  .ad_ops      = &nrf52_adcops,
  .ad_priv     = &nrf52_adcpriv,
};


/****************************************************************************
 * Private Functions
 ****************************************************************************/


/****************************************************************************
 * Name: adc_enable
 *
 * Description    : Enables or disables the specified ADC peripheral.
 *                  Also, starts a conversion when the ADC is not
 *                  triggered by timers
 *
 * Input Parameters:
 *
 *   enable - true:  enable ADC conversion
 *            false: disable ADC conversion
 *
 * Returned Value:
 *
 ****************************************************************************/

static void adc_enable(FAR struct nrf52_adc_s *priv, bool enable)
{

  ainfo("enable: %d\n", enable ? 1 : 0);

  if (enable)
    {
      /* prepare buffer , index & Enable the ADC */

      priv->end_flag = 0; /* set ping-pong buffer index to 0 */
      nrf_saadc_buffer_init(priv->adc_buf, priv->active_ch);

      /* start adc convert task and interrupt */

      if (ADC_MODE_CONTINUOUS == priv->mode)
        {
          nrf_saadc_task_trigger(NRF_SAADC_TASK_START);
        }
      else if (ADC_MODE_ONE_SHOT == priv->mode)
        {
          nrf_saadc_task_trigger(NRF_SAADC_TASK_START);
        }
      internal_adc_rxint(priv, true);
    }
  else
    {
      /* Stop ongoing conversions */

      nrf_saadc_task_trigger(NRF_SAADC_TASK_STOP);
      internal_adc_rxint(priv, false);
    }
}

/****************************************************************************
 * Name: adc_interrupt
 *
 * Description:
 *   Common ADC interrupt handler.
 *
 * Input Parameters:
 *
 * Returned Value:
 *
 ****************************************************************************/

static int adc_interrupt(int irq, FAR void *context, FAR void *arg)
{
  FAR struct adc_dev_s *dev = (FAR struct adc_dev_s *)arg;
  FAR struct nrf52_adc_s *priv = (FAR struct nrf52_adc_s *)dev->ad_priv;
  nrf_saadc_value_t *buf;
  int16_t data_index = 0;
  int ret = 0;

  if (nrf_saadc_event_check(NRF_SAADC_EVENT_END))
    {
      nrf_saadc_event_clear(NRF_SAADC_EVENT_END);
      irqinfo("Event: %s , flag %d.\n", (uint32_t)EVT_TO_STR(NRF_SAADC_EVENT_END), \
              priv->end_flag);

      if (priv->end_flag)
        {
          buf = priv->adc_second_buf;
        }
      else
        {
          buf = priv->adc_buf;
        }

      priv->end_flag = !priv->end_flag;

      for (int i = 0; i < MAX_BUF_LEN; i++)
        {
          int16_t data;
          if (priv->channel_flag & (1 << i))
            {
              /* call the high layer adc driver callback */

              data = buf[data_index];
              ret = priv->cb->au_receive(dev, i, data);
              data_index++;
              if (ret == (-ENOMEM))
                {
                  aerr("There is no Space to store data.\n");
                }
            }
        }

      if (ret == (-ENOMEM))
        {
          /* no memory , stop adc convert */

          adc_enable(priv, false);
        }
      else if (ADC_MODE_CONTINUOUS == priv->mode)
        {
          /*trigger start , then set next buffer */

          nrf_saadc_task_trigger(NRF_SAADC_TASK_START);
        }
      else if (ADC_MODE_ONE_SHOT == priv->mode)
        {
          /* one shot case: stop convert */
          adc_enable(priv, false);
        }
    }

  if (nrf_saadc_event_check(NRF_SAADC_EVENT_STARTED))
    {
      nrf_saadc_event_clear(NRF_SAADC_EVENT_STARTED);
      irqinfo("Event: %s.", (uint32_t)EVT_TO_STR(NRF_SAADC_EVENT_STARTED));

      /* if not one shot mode,  start to prepare next buffer */

      if (ADC_MODE_ONE_SHOT != priv->mode)
        {
          irqwarn("ADC: set the output buffer , flag %d.\n", priv->end_flag);

          if (priv->end_flag)
            {
              buf = priv->adc_buf;
            }
          else
            {
              buf = priv->adc_second_buf;
            }
          nrf_saadc_buffer_init(buf, priv->active_ch);
        }

      nrf_saadc_event_clear(NRF_SAADC_EVENT_END);
      nrf_saadc_task_trigger(NRF_SAADC_TASK_SAMPLE);
      priv->state = NRF_DRV_STATE_POWERED_ON;
    }

  if (nrf_saadc_event_check(NRF_SAADC_EVENT_CALIBRATEDONE))
    {
      nrf_saadc_event_clear(NRF_SAADC_EVENT_CALIBRATEDONE);
      irqinfo("Event: %s.", (uint32_t)EVT_TO_STR(NRF_SAADC_EVENT_CALIBRATEDONE));

    }
  if (nrf_saadc_event_check(NRF_SAADC_EVENT_STOPPED))
    {
      nrf_saadc_event_clear(NRF_SAADC_EVENT_STOPPED);
      irqinfo("Event: %s.", (uint32_t)EVT_TO_STR(NRF_SAADC_EVENT_STOPPED));

      priv->state = NRF_DRV_STATE_INITIALIZED;

      /* do we need to send out the partly data to high adc layer */
      /* ??? */
    }
  else
    {
      /* channel limit event */
    }

  return OK;
}



/****************************************************************************
 * Name: adc_bind
 *
 * Description:
 *   Bind the upper-half driver callbacks to the lower-half implementation.  This
 *   must be called early in order to receive ADC event notifications.
 *
 ****************************************************************************/

static int adc_bind(FAR struct adc_dev_s *dev,
                    FAR const struct adc_callback_s *callback)
{
  FAR struct nrf52_adc_s *priv = (FAR struct nrf52_adc_s *)dev->ad_priv;

  DEBUGASSERT(priv != NULL);
  priv->cb = callback;
  return OK;
}

/****************************************************************************
 * Name: adc_reset
 *
 * Description:
 *   Reset the ADC device.  Called early to initialize the hardware. This
 *   is called, before adc_setup() and on error conditions.
 *
 * Input Parameters:
 *
 * Returned Value:
 *
 ****************************************************************************/

static void adc_reset(FAR struct adc_dev_s *dev)
{
  return;
}


/****************************************************************************
 * Name: adc_setup
 *
 * Description:
 *   Configure the ADC. This method is called the first time that the ADC
 *   device is opened.  This will occur when the port is first opened.
 *   This setup includes configuring and attaching ADC interrupts.
 *   Interrupts are all disabled upon return.
 *
 * Input Parameters:
 *
 * Returned Value:
 *
 ****************************************************************************/

static int adc_setup(FAR struct adc_dev_s *dev)
{
  FAR struct nrf52_adc_s *priv = (FAR struct nrf52_adc_s *)dev->ad_priv;
  int ret;

  /* Attach the ADC interrupt */

  ret = irq_attach(priv->irq, adc_interrupt, dev);
  if (ret < 0)
    {
      ainfo("irq_attach failed: %d\n", ret);
      return ret;
    }

  /* set resolution & sample */

  nrf_saadc_resolution_set(priv->resolution);
  nrf_saadc_oversample_set(priv->oversample);

  /* Enable the ADC interrupt */

  ainfo("Enable the ADC interrupt: irq=%d\n", priv->irq);
  nrf_saadc_int_disable(NRF_SAADC_INT_ALL);
  nrf_saadc_event_clear(NRF_SAADC_EVENT_END);
  nrf_saadc_event_clear(NRF_SAADC_EVENT_STARTED);
  nrf_drv_common_irq_enable(priv->irq, NRF52_ADC_PRIORITY);

  nrf_saadc_enable();

  priv->state = NRF_DRV_STATE_INITIALIZED;

  return ret;
}

/****************************************************************************
 * Name: adc_shutdown
 *
 * Description:
 *   Disable the ADC.  This method is called when the ADC device is closed.
 *   This method reverses the operation the setup method.
 *
 * Input Parameters:
 *
 * Returned Value:
 *
 ****************************************************************************/

static void adc_shutdown(FAR struct adc_dev_s *dev)
{
  FAR struct nrf52_adc_s *priv = (FAR struct nrf52_adc_s *)dev->ad_priv;
  irqstate_t flags;


  /* Disable ADC interrupts and detach the ADC interrupt handler */

  adc_enable(priv, false);
  nrf_saadc_disable();

  flags = enter_critical_section();

  up_disable_irq(priv->irq);
  irq_detach(priv->irq);

  priv->state = NRF_DRV_STATE_UNINITIALIZED;
  leave_critical_section(flags);

  return;
}

/****************************************************************************
 * Name: up_adc_rxint
 *
 * Description:
 *   Call to enable or disable RX interrupts.
 *
 * Input Parameters:
 *
 * Returned Value:
 *
 ****************************************************************************/
static void up_adc_rxint(FAR struct adc_dev_s *dev, bool enable)
{
  /* interrupt enable & disable on convert and stop
   * directly enable here will cause interrupt always trigger
   */
  return;
}

static void internal_adc_rxint(FAR struct nrf52_adc_s *priv, bool enable)
{

  ainfo("ADC: enable: %d\n", enable ? 1 : 0);

  if (enable)
    {
      /* Enable the analog watchdog / overrun interrupts, and if no DMA,
       * end-of-conversion ADC.
       */

      nrf_saadc_int_enable(priv->irqmask);
    }
  else
    {
      /* Disable all ADC interrupts */

      nrf_saadc_int_disable(NRF_SAADC_INT_ALL);
    }

  return;
}

/****************************************************************************
 * Name: adc_set_channel_config
 *
 * Description:
 *   Sets the ADC channel.
 *
 * Input Parameters:
 *   dev - pointer to device structure used by the driver
 *   ch  - ADC channel number + 1. 0 reserved for all configured channels
 *
 * Returned Value:
 *   int - errno
 *
 ****************************************************************************/

static int adc_set_channel_config(adc_channel_config_t *config)
{
  assert(config != NULL);
  assert(config->channel < MAX_ADC_CH_NUM);
  assert(config->pin_p < ANALOG_PINMUX_MAX_VALUE);
  assert(config->pin_n < ANALOG_PINMUX_MAX_VALUE);

  NRF_SAADC->CH[config->channel].CONFIG =
    ((config->resistor_p   << SAADC_CH_CONFIG_RESP_Pos)   & SAADC_CH_CONFIG_RESP_Msk)
    | ((config->resistor_n << SAADC_CH_CONFIG_RESN_Pos)   & SAADC_CH_CONFIG_RESN_Msk)
    | ((config->gain       << SAADC_CH_CONFIG_GAIN_Pos)   & SAADC_CH_CONFIG_GAIN_Msk)
    | ((config->ref  << SAADC_CH_CONFIG_REFSEL_Pos) & SAADC_CH_CONFIG_REFSEL_Msk)
    | ((config->time   << SAADC_CH_CONFIG_TACQ_Pos)   & SAADC_CH_CONFIG_TACQ_Msk)
    | ((config->mode       << SAADC_CH_CONFIG_MODE_Pos)   & SAADC_CH_CONFIG_MODE_Msk);

  nrf_saadc_channel_input_set(config->channel, config->pin_p, config->pin_n);

  return OK;
}

/****************************************************************************
 * Name: adc_ioctl
 *
 * Description:
 *   All ioctl calls will be routed through this method.
 *
 * Input Parameters:
 *   dev - pointer to device structure used by the driver
 *   cmd - command
 *   arg - arguments passed with command
 *
 * Returned Value:
 *
 ****************************************************************************/

static int adc_ioctl(FAR struct adc_dev_s *dev, int cmd, unsigned long arg)
{
  FAR struct nrf52_adc_s *priv = (FAR struct nrf52_adc_s *)dev->ad_priv;
  int ret = OK;

  switch (cmd)
    {
      case ANIOC_TRIGGER:
        /* one shot trigger */
        adc_enable(priv, true);
        break;

      case ANIOC_START_CONV:
        {
          adc_enable(priv, true);
        }
        break;

      case ANIOC_STOP_CONV:
        adc_enable(priv, false);
        break;

      default:
        aerr("ERROR: Unknown cmd: %d\n", cmd);
        ret = -ENOTTY;
        break;
    }

  return ret;
}

/****************************************************************************
 * Public Functions
 ****************************************************************************/

/****************************************************************************
 * Name: nrf52_adc_initialize
 *
 * Description:
 *   Initialize the ADC.
 *
 *   The logic is, save nchannels : # of channels (conversions) in ADC_SQR1_L
 *   Then, take the chanlist array and store it in the SQR Regs,

 *
 * Input Parameters:
 *   intf      - Could be {1,2,3} for ADC1, ADC2, or ADC3
 *   chanlist  - The list of channels
 *   cchannels - Number of channels
 *
 * Returned Value:
 *   Valid ADC device structure reference on succcess; a NULL on failure
 *
 ****************************************************************************/

int nrf52_adc_initialize(adc_config_t *config,
                         adc_channel_config_t *ch_config, int nchannels)
{
  int ret = OK;
  FAR struct nrf52_adc_s *priv;

  assert(config != NULL);

  ainfo("nchannels: %d\n", nchannels);

  /* Configure the selected ADC */

  priv = (FAR struct nrf52_adc_s *)nrf52_adcdev.ad_priv;
  priv->resolution = config->resolution;
  priv->oversample = config->oversample;
  priv->mode       = config->mode;
  priv->channel_flag = 0;
  priv->active_ch = nchannels;
  for (int i = 0; i < nchannels; i++)
    {
      priv->channel_flag |= 1 << ch_config[i].channel;
      if (ADC_MODE_CONTINUOUS == config->mode && nchannels > 1)
        {
          aerr("ADC: Continue Mode can't work under multi-channel.\n");
          return -EINVAL;
        }
      ret |= adc_set_channel_config(&ch_config[i]);
    }

  if (ret < 0)
    {
      aerr("setup channel FAIL\n");
      return ret;
    }

  priv->irqmask = NRF_SAADC_INT_STARTED | NRF_SAADC_EVENT_STOPPED | NRF_SAADC_INT_END;
  priv->state = NRF_DRV_STATE_UNINITIALIZED;
  ret = adc_register("/dev/adc0", &nrf52_adcdev);

  return ret;
}

#endif /* CONFIG_NRF52_ADC */


/****************************************************************************
 * arch/arm/src/nrf52/nrf52_qspi.c
 *
 *   Copyright (C) 2018 Zglue Inc Ltd. All rights reserved.
 *   Author: Levin Li   <zhiqiang@zglue.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name NuttX nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/****************************************************************************
 * Included Files
 ****************************************************************************/

#include <nuttx/config.h>

#include <sys/types.h>
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <semaphore.h>
#include <errno.h>
#include <assert.h>
#include <debug.h>

#include <arch/board/board.h>

#include <nuttx/arch.h>
#include <nuttx/wdog.h>
#include <nuttx/clock.h>
#include <nuttx/kmalloc.h>
#include <nuttx/semaphore.h>
#include <nuttx/spi/qspi.h>

#include "up_internal.h"
#include "up_arch.h"
#include "cache.h"

#include "nrf_gpio.h"
#include "nrf_qspi.h"

#include "nrf52_qspi.h"

#ifdef CONFIG_NRF52_QSPI

/****************************************************************************
 * Pre-processor Definitions
 ****************************************************************************/

/* QSPI memory synchronization */

#define MEMORY_SYNC()     do { ARM_DSB(); ARM_ISB(); } while (0)

/* Debug *******************************************************************/
/* Check if QSPI debug is enabled */


/* Sanity check that board.h defines requisite QSPI pinmap options for */

#if (!defined(BOARD_QSPI_CS_PIN) || !defined(BOARD_QSPI_SCK_PIN) || \
  !defined(BOARD_QSPI_DIO0_PIN) || !defined(BOARD_QSPI_DIO1_PIN) || \
  !defined(BOARD_QSPI_DIO2_PIN) || !defined(BOARD_QSPI_DIO3_PIN))
#error "you must define QSPI pinmapping options for"
#error "    BORAD_QSPI_CS_PIN BORAD_QSPI_SCK_PIN"
#error "    BORAD_QSPI_DIO0_PIN BORAD_QSPI_DIO1_PIN"
#error "    BORAD_QSPI_DIO2_PIN BORAD_QSPI_DIO3_PIN in your board.h"
#endif


/* Clocking *****************************************************************/
/* The QSPI bit rate clock is generated by dividing the peripheral clock by
 * a value between 1 and 255
 */

#define NRF52_QSPI_CLOCK    32000000UL  /* Frequency of the QSPI clock */

#define ADDRMODE_24BIT      0
#define ADDRMODE_32BIT      1

#define QSPI_WAIT_READY() do {                                         \
        while (!nrf_qspi_event_check(NRF_QSPI, NRF_QSPI_EVENT_READY)); \
    } while (0)

/****************************************************************************
 * Private Types
 ****************************************************************************/

/* The state of the QSPI controller.
 *
 * NOTE: the STM32L4 supports only a single QSPI peripheral.  Logic here is
 * designed to support multiple QSPI peripherals.
 */

struct nrf52_qspidev_s
{
  struct qspi_dev_s qspi;         /* Externally visible part of the QSPI interface */
  NRF_QSPI_Type    *base;         /* QSPI controller register base address */
  uint32_t frequency;             /* Requested clock frequency */
  uint32_t actual;                /* Actual clock frequency */
  uint8_t mode;                   /* Mode 0,3 */
  uint8_t intf;                   /* QSPI controller number (0) */
  nrf_qspi_phy_conf_t phy_cnf;
  nrf_qspi_prot_conf_t prot_cnf;

  uint8_t     irq;
  bool initialized;               /* TRUE: Controller has been initialized */
  sem_t exclsem;                  /* Assures mutually exclusive access to QSPI */
  sem_t op_sem;                   /* Block until complete */
};


/****************************************************************************
 * Private Function Prototypes
 ****************************************************************************/
/* Interrupts */

static int     qspi_interrupt(int irq, void *context, FAR void *arg);

/* QSPI methods */

static int      qspi_lock(struct qspi_dev_s *dev, bool lock);
static uint32_t qspi_setfrequency(struct qspi_dev_s *dev, uint32_t frequency);
static void     qspi_setmode(struct qspi_dev_s *dev, enum qspi_mode_e mode);
static void     qspi_setbits(struct qspi_dev_s *dev, int nbits);
static int      qspi_command(struct qspi_dev_s *dev,
                             struct qspi_cmdinfo_s *cmdinfo);
static int      qspi_memory(struct qspi_dev_s *dev,
                            struct qspi_meminfo_s *meminfo);
static FAR void *qspi_alloc(FAR struct qspi_dev_s *dev, size_t buflen);
static void     qspi_free(FAR struct qspi_dev_s *dev, FAR void *buffer);

/* Initialization */

/****************************************************************************
 * Private Data
 ****************************************************************************/

static const nrf_qspi_pins_t g_pinconfig =
{
  .csn_pin = BOARD_QSPI_CS_PIN,
  .sck_pin = BOARD_QSPI_SCK_PIN,
  .io0_pin = BOARD_QSPI_DIO0_PIN,
  .io1_pin = BOARD_QSPI_DIO1_PIN,
  .io2_pin = BOARD_QSPI_DIO2_PIN,
  .io3_pin = BOARD_QSPI_DIO3_PIN
};

/* QSPI0 driver operations */

static const struct qspi_ops_s g_qspi0ops =
{
  .lock              = qspi_lock,
  .setfrequency      = qspi_setfrequency,
  .setmode           = qspi_setmode,
  .setbits           = qspi_setbits,
  .command           = qspi_command,
  .memory            = qspi_memory,
  .alloc             = qspi_alloc,
  .free              = qspi_free,
};

/* This is the overall state of the QSPI0 controller */

static struct nrf52_qspidev_s g_qspi0dev =
{
  .qspi          =
  {
    .ops         = &g_qspi0ops,
  },
  .base          = NRF_QSPI,
  .frequency     = NRF52_QSPI_CLOCK,
  .mode          = QSPIDEV_MODE0,
  .irq           = QSPI_IRQn,
  .intf          = 0,
  .phy_cnf       =
  {
    .sck_delay  = 2,
    .dpmen      = false,
    .spi_mode   = NRF_QSPI_MODE_0,
    .sck_freq   = 0, /* default is 32MHz */
  },
  .prot_cnf      =
  {
    .readoc      = NRF_QSPI_READOC_READ4IO,
    .writeoc     = NRF_QSPI_WRITEOC_PP4IO,
    .addrmode    = NRF_QSPI_ADDRMODE_24BIT,
    .dpmconfig   = false,
  }
};

/****************************************************************************
 * Private Functions
 ****************************************************************************/


/****************************************************************************
 * Name: qspi_setup_cmd
 *
 * Description:
 *   Setup our transaction descriptor from a command info structure
 *
 * Input Parameters:
 *   xctn  - the transaction descriptor we setup
 *   cmdinfo  - the command info (originating from the MTD device)
 *
 * Returned Value:
 *   OK, or -errno if invalid
 *
 ****************************************************************************/

static int qspi_setup_cmd(struct nrf52_qspidev_s *priv,
                          const struct qspi_cmdinfo_s *cmdinfo)
{
  nrf_qspi_cinstr_conf_t cust_conf;
  uint32_t cuscmd_len = 0;
  DEBUGASSERT((cmdinfo->cmd < 0xFF) && (cmdinfo != NULL));

  spiinfo("Transfer:\n");
  spiinfo("  flags: %02x, cmd: %#x\n", cmdinfo->flags, cmdinfo->cmd);

  if (QSPICMD_ISDATA(cmdinfo->flags))
    {
      spiinfo("  %s Data:\n", QSPICMD_ISWRITE(cmdinfo->flags) ? "Write" : "Read");
      spiinfo("    buffer/length: %p/%d\n", cmdinfo->buffer, cmdinfo->buflen);
    }
  else if (QSPICMD_ISADDRESS(cmdinfo->flags))
    {
      cuscmd_len = cmdinfo->addrlen;
      nrf_qspi_cinstrdata_set(priv->base, \
                              cuscmd_len + NRF_QSPI_CINSTR_LEN_1B, (void const *)&cmdinfo->addr);
    }

  if (QSPICMD_ISWRITE(cmdinfo->flags))
    {
      cuscmd_len = cmdinfo->buflen;
      nrf_qspi_cinstrdata_set(priv->base, \
                              cuscmd_len + NRF_QSPI_CINSTR_LEN_1B, cmdinfo->buffer);
    }

  nrf_qspi_int_disable(priv->base, NRF_QSPI_INT_READY_MASK);
  nrf_qspi_event_clear(priv->base, NRF_QSPI_EVENT_READY);

  cust_conf.opcode = (uint8_t)cmdinfo->cmd;
  cust_conf.length = cmdinfo->buflen + NRF_QSPI_CINSTR_LEN_1B;
  cust_conf.io2_level = true;
  cust_conf.io3_level = true;
  cust_conf.wipwait = true;
  cust_conf.wren = false;
  nrf_qspi_cinstr_transfer_start(priv->base, &cust_conf);
  QSPI_WAIT_READY();

  nrf_qspi_event_clear(priv->base, NRF_QSPI_EVENT_READY);
  nrf_qspi_int_enable(priv->base, NRF_QSPI_INT_READY_MASK);

  if (QSPICMD_ISREAD(cmdinfo->flags))
    {
      /* opcode will take one byte */
      nrf_qspi_cinstrdata_get(priv->base, \
                              cmdinfo->buflen + NRF_QSPI_CINSTR_LEN_1B, cmdinfo->buffer);
    }

  return OK;
}

static int qspi_setup_memory_cmd(struct nrf52_qspidev_s *priv,
                                 const struct qspi_meminfo_s *meminfo)
{
  static const uint16_t write_cmd[] = {0x02, 0xa2, 0x32, 0x38};
  static const uint16_t read_cmd[] = {0x0b, 0x3b, 0xbb, 0x6b, 0xeb};
  uint16_t cmd;
  uint8_t need_update = false;

  if (QSPIMEM_ISWRITE(meminfo->flags))
    {
      cmd = write_cmd[priv->prot_cnf.writeoc];
      if (cmd != meminfo->cmd)
        {
          uint8_t total_w_cmd = sizeof(write_cmd) / sizeof(uint16_t);
          int i ;
          for (i = 0; i < total_w_cmd; i++)
            {
              if (write_cmd[i] == meminfo->cmd)
                {
                  break;
                }
            }

          if (i < total_w_cmd)
            {
              need_update = true;
              priv->prot_cnf.writeoc = i;
              spiinfo("Pre W cmd: %#x, New W cmd:%#x\n",
                      cmd, meminfo->cmd);
            }
          else
            {
              spierr("Invalid Write Cmd: %d.\n", meminfo->cmd);
              return -EINVAL;
            }
        }
    }
  else if (QSPIMEM_ISREAD(meminfo->flags))
    {
      cmd = read_cmd[priv->prot_cnf.readoc];
      if (cmd != meminfo->cmd)
        {
          uint8_t total_r_cmd = sizeof(read_cmd) / sizeof(uint16_t);
          int i;
          for (i = 0; i < total_r_cmd; i++)
            {
              if (read_cmd[i] == meminfo->cmd)
                {
                  break;
                }
            }

          if (i < total_r_cmd)
            {
              need_update = true;
              priv->prot_cnf.readoc = i;
              spiinfo("Pre R cmd: %#x, New R cmd:%#x\n",
                      cmd, meminfo->cmd);
            }
          else
            {
              spierr("Invalid Read Cmd: %d.\n", meminfo->cmd);
              return -EINVAL;
            }

        }
    }
  else
    {
      spierr("Not Memory R/W command: meminfo->flags %#x!!!\n", meminfo->flags);
      return -EINVAL;
    }

  /*nordic only support 24bit or 32bit len */
  if ( meminfo->addrlen == 3 || meminfo->addrlen == 4)
    {
      cmd = meminfo->addrlen - 3 + ADDRMODE_24BIT;
    }
  else
    {
      spierr("Not support addrlen: %d.\n", meminfo->addrlen);
      return -EOPNOTSUPP;
    }

  if (priv->prot_cnf.addrmode != cmd)
    {
      spiinfo("Pre Addr Mode: %d, New Addr Mode: %d\n",
              priv->prot_cnf.addrmode, cmd);

      priv->prot_cnf.addrmode = cmd;
      need_update = true;
    }

  if (need_update)
    {
      spiinfo("R oc:%d, W oc:$d, A-mode:%d\n", priv->prot_cnf.readoc,
              priv->prot_cnf.writeoc, priv->prot_cnf.addrmode);

      nrf_qspi_ifconfig0_set(priv->base, &priv->prot_cnf);
    }

  return OK;
}
/****************************************************************************
 * Name: qspi_interrupt
 *
 * Description:
 *   Interrupt handler; we handle all QSPI cases -- reads, writes,
 *   automatic status polling, etc.
 *
 * Input Parameters:
 *   irq  -
 *   context  -
 *
 * Returned Value:
 *   OK means we handled it
 *
 ****************************************************************************/

static int qspi_interrupt(int irq, void *context, FAR void *arg)
{
  struct nrf52_qspidev_s *priv = (struct nrf52_qspidev_s *)arg;

  if (nrf_qspi_event_check(NRF_QSPI, NRF_QSPI_EVENT_READY))
    {
      nrf_qspi_event_clear(NRF_QSPI, NRF_QSPI_EVENT_READY);
      sem_post(&priv->op_sem);
    }

  return OK;
}

static void nrf52_qspi_activate(struct nrf52_qspidev_s *priv, bool activate)
{
  if (activate)
    {
      nrf_qspi_int_disable(priv->base, NRF_QSPI_INT_READY_MASK);

      nrf_qspi_event_clear(priv->base, NRF_QSPI_EVENT_READY);
      nrf_qspi_task_trigger(priv->base, NRF_QSPI_TASK_ACTIVATE);

      // Waiting for the peripheral to activate
      QSPI_WAIT_READY();
      nrf_qspi_event_clear(priv->base, NRF_QSPI_EVENT_READY);
      nrf_qspi_int_enable(priv->base, NRF_QSPI_INT_READY_MASK);
    }
  else
    {
      nrf_qspi_task_trigger(priv->base, NRF_QSPI_TASK_DEACTIVATE);
    }
}
/****************************************************************************
 * Name: qspi_lock
 *
 * Description:
 *   On QSPI buses where there are multiple devices, it will be necessary to
 *   lock QSPI to have exclusive access to the buses for a sequence of
 *   transfers.  The bus should be locked before the chip is selected. After
 *   locking the QSPI bus, the caller should then also call the setfrequency,
 *   setbits, and setmode methods to make sure that the QSPI is properly
 *   configured for the device.  If the QSPI bus is being shared, then it
 *   may have been left in an incompatible state.
 *
 * Input Parameters:
 *   dev  - Device-specific state data
 *   lock - true: Lock QSPI bus, false: unlock QSPI bus
 *
 * Returned Value:
 *   None
 *
 ****************************************************************************/

static int qspi_lock(struct qspi_dev_s *dev, bool lock)
{
  struct nrf52_qspidev_s *priv = (struct nrf52_qspidev_s *)dev;

  spiinfo("lock=%d\n", lock);
  if (lock)
    {
      /* Take the semaphore (perhaps waiting) */

      while (sem_wait(&priv->exclsem) != 0)
        {
          /* The only case that an error should occur here is if the wait
           * was awakened by a signal.
           */

          ASSERT(errno == EINTR);
        }
    }
  else
    {
      (void)sem_post(&priv->exclsem);
    }

  return OK;
}

/****************************************************************************
 * Name: qspi_setfrequency
 *
 * Description:
 *   Set the QSPI frequency.
 *
 * Input Parameters:
 *   dev -       Device-specific state data
 *   frequency - The QSPI frequency requested
 *
 * Returned Value:
 *   Returns the actual frequency selected
 *
 ****************************************************************************/

static uint32_t qspi_setfrequency(struct qspi_dev_s *dev, uint32_t frequency)
{
  struct nrf52_qspidev_s *priv = (struct nrf52_qspidev_s *)dev;
  uint32_t actual = 0;
  uint32_t prescaler = 0;

  spiinfo("frequency=%d\n", frequency);
  DEBUGASSERT(priv);

  /* Check if the requested frequency is the same as the frequency selection */

  if (frequency > NRF52_QSPI_CLOCK)
    {
      spierr("Wrong Frequency parameter , the MAX Freq is %d.\n", NRF52_QSPI_CLOCK);
      return -EINVAL;
    }

  if (priv->frequency == frequency)
    {
      /* We are already at this frequency.  Return the actual. */

      return priv->actual;
    }

  /* Configure QSPI to a frequency as close as possible to the requested
   * frequency.
   *
   *   QSCK frequency = NRF52_QSPI_CLOCK / prescaler, or
   *     prescaler = NRF52_QSPI_CLOCK / frequency
   *
   * Where prescaler can have the range 0 to 15 .
   * NOTE that a "ceiling" type of calculation is performed.
   * 'frequency' is treated as a not-to-exceed value.
   */

  prescaler = (frequency + NRF52_QSPI_CLOCK - 1) / frequency;

  /* Make sure that the divider is within range
   * SCK frequency is given as 32 MHz / (SCKFREQ + 1).
   */
  prescaler -= 1;

  if (prescaler < 1)
    {
      prescaler = 0;
    }
  else if (prescaler > 15)
    {
      prescaler = 15;
    }

  /* Calculate the new actual frequency */

  actual = NRF52_QSPI_CLOCK / prescaler;
  spiinfo("prescaler=%d actual=%d\n", prescaler, actual);

  /* Save the frequency setting */

  priv->phy_cnf.sck_freq = (nrf_qspi_frequency_t)prescaler;

  irqstate_t flags = enter_critical_section();
  nrf52_qspi_activate(priv, false);
  nrf_qspi_ifconfig1_set(priv->base, &priv->phy_cnf);
  nrf52_qspi_activate(priv, true);
  leave_critical_section(flags);

  priv->frequency = frequency;
  priv->actual    = actual;

  spiinfo("Frequency %d->%d\n", frequency, actual);
  return actual;
}

/****************************************************************************
 * Name: qspi_setmode
 *
 * Description:
 *   Set the QSPI mode. Optional.  See enum qspi_mode_e for mode definitions.
 *   NOTE:  the STM32L4 QSPI supports only modes 0 and 3.
 *
 * Input Parameters:
 *   dev -  Device-specific state data
 *   mode - The QSPI mode requested
 *
 * Returned Value:
 *   none
 *
 ****************************************************************************/

static void qspi_setmode(struct qspi_dev_s *dev, enum qspi_mode_e mode)
{
  struct nrf52_qspidev_s *priv = (struct nrf52_qspidev_s *)dev;

  spiinfo("new mode=%d, pre mode=%d\n", mode, priv->mode);

  /* Has the mode changed? */

  if (mode != priv->mode)
    {
      /* Yes... Set the mode appropriately:
       *
       * QSPI  CPOL CPHA
       * MODE
       *  0    0    0
       *  1    0    1
       *  2    1    0
       *  3    1    1
       */
      switch (mode)
        {
          case QSPIDEV_MODE0: /* CPOL=0; CPHA=0 */
            priv->phy_cnf.spi_mode = NRF_QSPI_MODE_0;
            break;

          case QSPIDEV_MODE3: /* CPOL=1; CPHA=1 */
            priv->phy_cnf.spi_mode = NRF_QSPI_MODE_1;
            break;

          case QSPIDEV_MODE1: /* CPOL=0; CPHA=1 */
          case QSPIDEV_MODE2: /* CPOL=1; CPHA=0 */
            spiinfo("unsupported mode=%d\n", mode);
          default:
            DEBUGASSERT(FALSE);
            return;
        }

      irqstate_t flags = enter_critical_section();
      nrf52_qspi_activate(priv, false);
      nrf_qspi_ifconfig1_set(priv->base, &priv->phy_cnf);
      nrf52_qspi_activate(priv, true);
      leave_critical_section(flags);

      /* Save the mode so that subsequent re-configurations will be faster */
      priv->mode = mode;
    }
}

/****************************************************************************
 * Name: qspi_setbits
 *
 * Description:
 *   Set the number if bits per word.
 *   NOTE:  the STM32L4 QSPI only supports 8 bits, so this does nothing.
 *
 * Input Parameters:
 *   dev -  Device-specific state data
 *   nbits - The number of bits requests
 *
 * Returned Value:
 *   none
 *
 ****************************************************************************/

static void qspi_setbits(struct qspi_dev_s *dev, int nbits)
{
  /* Not meaningful for the STM32L4x6 */

  if (8 != nbits)
    {
      spiinfo("unsupported nbits=%d\n", nbits);
      DEBUGASSERT(FALSE);
    }
}

/****************************************************************************
 * Name: qspi_command
 *
 * Description:
 *   Perform one QSPI data transfer
 *
 * Input Parameters:
 *   dev     - Device-specific state data
 *   cmdinfo - Describes the command transfer to be performed.
 *
 * Returned Value:
 *   Zero (OK) on SUCCESS, a negated errno on value of failure
 *
 ****************************************************************************/

static int qspi_command(struct qspi_dev_s *dev,
                        struct qspi_cmdinfo_s *cmdinfo)
{
  struct nrf52_qspidev_s *priv = (struct nrf52_qspidev_s *)dev;
  int ret = OK;
  uint16_t cmd;
  nrf_qspi_erase_len_t len_cmd = 0xFF;

  spiinfo("Cmd: %d, flags: $d\n", cmdinfo->cmd, cmdinfo->flags);

  /* seperate erase command from cmdinfo */

  cmd = cmdinfo->cmd;

  switch (cmd)
    {
      case 0x20:
        len_cmd = NRF_QSPI_ERASE_LEN_4KB;
        break;
      case 0xD8:
        len_cmd = NRF_QSPI_ERASE_LEN_64KB;
        break;
      case 0xC7:
        len_cmd = NRF_QSPI_ERASE_LEN_ALL;
        break;
      default:
        len_cmd = 0xFF;
    }

  if (0xFF != len_cmd)
    {
      spiinfo("Erase cmd: $d, nrf_cmd :%d\n", cmd, len_cmd);
      nrf_qspi_erase_ptr_set(priv->base, cmdinfo->addr, len_cmd);
      nrf_qspi_task_trigger(priv->base, NRF_QSPI_TASK_ERASESTART);

      /* Wait for the interrupt routine to finish it's magic */

      sem_wait(&priv->op_sem);
    }
  else
    {
      ret = qspi_setup_cmd(priv, cmdinfo);
    }

  if (OK != ret)
    {
      return ret;
    }

  return ret;
}

/****************************************************************************
 * Name: qspi_memory
 *
 * Description:
 *   Perform one QSPI memory transfer
 *
 * Input Parameters:
 *   dev     - Device-specific state data
 *   meminfo - Describes the memory transfer to be performed.
 *
 * Returned Value:
 *   Zero (OK) on SUCCESS, a negated errno on value of failure
 *
 ****************************************************************************/

static int qspi_memory(struct qspi_dev_s *dev,
                       struct qspi_meminfo_s *meminfo)
{
  struct nrf52_qspidev_s *priv = (struct nrf52_qspidev_s *)dev;
  int ret = OK;

  /* Prepare for transaction */


  /* interrupt mode will need access to the transaction context */

  DEBUGASSERT(meminfo->buffer != NULL && meminfo->buflen > 0);
  DEBUGASSERT(((uint32_t)meminfo->buffer & 0x03) == 0);

  ret = qspi_setup_memory_cmd(priv, meminfo);

  if (OK != ret)
    {
      spierr("SPI Memory transfer Error.\n");
      return ret;
    }

  if (QSPIMEM_ISWRITE(meminfo->flags))
    {

      /* Set up the Communications Configuration Register as per command
       * info
       */
      nrf_qspi_write_buffer_set(priv->base, meminfo->buffer, \
                                (uint32_t)meminfo->buflen, meminfo->addr);

      nrf_qspi_task_trigger(priv->base, NRF_QSPI_TASK_WRITESTART);
    }
  else if (QSPIMEM_ISREAD(meminfo->flags))
    {
      nrf_qspi_read_buffer_set(priv->base, meminfo->buffer, \
                               (uint32_t)meminfo->buflen, meminfo->addr);

      nrf_qspi_task_trigger(priv->base, NRF_QSPI_TASK_READSTART);
    }

  /* Wait for the interrupt routine to finish it's magic */

  sem_wait(&priv->op_sem);

  MEMORY_SYNC();

  return ret;
}

/****************************************************************************
 * Name: qspi_alloc
 *
 * Description:
 *   Allocate a buffer suitable for DMA data transfer
 *
 * Input Parameters:
 *   dev    - Device-specific state data
 *   buflen - Buffer length to allocate in bytes
 *
 * Returned Value:
 *   Address of tha allocated memory on success; NULL is returned on any
 *   failure.
 *
 ****************************************************************************/

static FAR void *qspi_alloc(FAR struct qspi_dev_s *dev, size_t buflen)
{
  /* Here we exploit the carnal knowledge the kmm_malloc() will return memory
   * aligned to 64-bit addresses.  The buffer length must be large enough to
   * hold the rested buflen in units a 32-bits.
   */

  return kmm_malloc(buflen);
}

/****************************************************************************
 * Name: QSPI_FREE
 *
 * Description:
 *   Free memory returned by QSPI_ALLOC
 *
 * Input Parameters:
 *   dev    - Device-specific state data
 *   buffer - Buffer previously allocated via QSPI_ALLOC
 *
 * Returned Value:
 *   None.
 *
 ****************************************************************************/

static void qspi_free(FAR struct qspi_dev_s *dev, FAR void *buffer)
{
  if (buffer)
    {
      kmm_free(buffer);
    }
}

/****************************************************************************
 * Name: qspi_hw_initialize
 *
 * Description:
 *   Initialize the QSPI peripheral from hardware reset.
 *
 * Input Parameters:
 *   priv - Device state structure.
 *
 * Returned Value:
 *   Zero (OK) on SUCCESS, a negated errno on value of failure
 *
 ****************************************************************************/

static int qspi_hw_initialize(struct nrf52_qspidev_s *priv)
{

  /* Disable the QSPI; set pin confiuration and default interface config */

  nrf_qspi_disable(priv->base);

  nrf_qspi_pins_set(priv->base, &g_pinconfig);

  nrf_qspi_ifconfig0_set(priv->base, &priv->prot_cnf);
  nrf_qspi_ifconfig1_set(priv->base, &priv->phy_cnf);


  /* Enable QSPI */

  nrf_qspi_int_disable(priv->base, NRF_QSPI_INT_READY_MASK);

  nrf_qspi_enable(priv->base);

  nrf_qspi_event_clear(priv->base, NRF_QSPI_EVENT_READY);
  nrf_qspi_task_trigger(priv->base, NRF_QSPI_TASK_ACTIVATE);

  // Waiting for the peripheral to activate
  QSPI_WAIT_READY();

  /* Enable ready interrupt*/

  nrf_qspi_event_clear(priv->base, NRF_QSPI_EVENT_READY);
  nrf_qspi_int_enable(priv->base, NRF_QSPI_INT_READY_MASK);

  return OK;
}

/****************************************************************************
 * Public Functions
 ****************************************************************************/

/****************************************************************************
 * Name: nrf52_qspi_initialize
 *
 * Description:
 *   Initialize the selected QSPI port in master mode
 *
 * Input Parameter:
 *   intf - Interface number(must be zero)
 *
 * Returned Value:
 *   Valid QSPI device structure reference on success; a NULL on failure
 *
 ****************************************************************************/

struct qspi_dev_s *nrf52_qspi_initialize(int intf)
{
  struct nrf52_qspidev_s *priv;
  int ret;

  /* The nrf52840 has only a single QSPI port */

  spiinfo("intf: %d\n", intf);
  DEBUGASSERT(intf == 0);

  /* Select the QSPI interface */

  if (intf == 0)
    {
      /* If this function is called multiple times, the following operations
       * will be performed multiple times.
       */

      /* Select QSPI0 */

      priv = &g_qspi0dev;

    }
  else
    {
      spierr("ERROR: QSPI%d not supported\n", intf);
      return NULL;
    }

  /* Has the QSPI hardware been initialized? */

  if (!priv->initialized)
    {
      /* Now perform one time initialization */
      /* Initialize the QSPI semaphore that enforces mutually exclusive
       * access to the QSPI registers.
       */

      /* Attach the interrupt handler */

      ret = irq_attach(priv->irq, qspi_interrupt, (void *)priv);
      if (ret < 0)
        {
          spierr("ERROR: Failed to attach irq %d\n", priv->irq);
          return NULL;
        }

      sem_init(&priv->exclsem, 0, 1);

      /* Initialize the semaphore that blocks until the operation completes.
       * This semaphore is used for signaling and, hence, should not have
       * priority inheritance enabled.
       */

      sem_init(&priv->op_sem, 0, 0);
      sem_setprotocol(&priv->op_sem, SEM_PRIO_NONE);

      /* Perform hardware initialization.  Puts the QSPI into an active
       * state.
       */

      qspi_hw_initialize(priv);

      /* Enable interrupts at the NVIC */

      priv->initialized = true;

      up_enable_irq(priv->irq);
    }


  return &priv->qspi;

}

#endif /* CONFIG_NRF52_QSPI */

